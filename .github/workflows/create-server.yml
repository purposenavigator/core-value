name: Create and Provision Server

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: 'AWS Region'
        required: true
        default: 'us-east-1'
      ec2_ami_id:
        description: 'Ubuntu 22.04 LTS AMI ID (Verify for your region)'
        required: true
        default: 'ami-053b0d53c279acc90' # EXAMPLE: Ubuntu 22.04 LTS for us-east-1
      ec2_instance_type:
        description: 'EC2 Instance Type'
        required: true
        default: 't2.micro'
      ec2_key_pair_name:
        description: 'EC2 Key Pair Name (MUST exist in the AWS region)'
        required: true
        default: 'self-analyzation-key'
      security_group_name:
        description: 'Name for the EC2 Security Group'
        required: true
        default: 'my-app-ec2-sg'
      ec2_instance_name_tag:
        description: 'Value for the Name tag of the EC2 instance'
        required: true
        default: 'my-app-instance'
      ssh_allowed_cidr:
        description: 'CIDR block allowed for SSH. 0.0.0.0/0 is for Actions runner IP.'
        required: true
        default: '0.0.0.0/0'
      repository_to_clone:
        description: 'Repository to clone (e.g., your-username/your-repo-name)'
        required: true
        default: 'purposenavigator/core-value'
      repository_branch:
        description: 'Branch to clone'
        required: true
        default: 'main'

jobs:
  # Job 1: Provision infrastructure (EC2 instance) on AWS
  provision_infrastructure:
    runs-on: ubuntu-latest
    outputs: # Make this job's outputs available to other jobs
      instance_id: ${{ steps.launch_ec2.outputs.INSTANCE_ID }}
      public_ip: ${{ steps.launch_ec2.outputs.PUBLIC_IP }}
      security_group_id: ${{ steps.create_sg.outputs.SECURITY_GROUP_ID }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.aws_region }}

      # (Below: Steps for key pair verification, security group creation, and EC2 instance launch remain unchanged)
      - name: Verify EC2 Key Pair Existence
        id: verify_key_pair
        run: |
          echo "Verifying EC2 Key Pair: ${{ github.event.inputs.ec2_key_pair_name }}"
          if aws ec2 describe-key-pairs --key-names "${{ github.event.inputs.ec2_key_pair_name }}" --region "${{ github.event.inputs.aws_region }}" >/dev/null 2>&1; then
            echo "Key Pair '${{ github.event.inputs.ec2_key_pair_name }}' found."
          else
            echo "Error: Key Pair '${{ github.event.inputs.ec2_key_pair_name }}' not found in region '${{ github.event.inputs.aws_region }}'."
            echo "Please create it in the AWS EC2 console and ensure you have the private key."
            exit 1
          fi

      - name: Create Security Group (Idempotent)
        id: create_sg
        run: |
          SG_NAME="${{ github.event.inputs.security_group_name }}"
          AWS_REGION="${{ github.event.inputs.aws_region }}"
          SSH_CIDR="${{ github.event.inputs.ssh_allowed_cidr }}"

          # Attempt to get default VPC ID
          VPC_ID=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query "Vpcs[0].VpcId" --output text --region "$AWS_REGION")
          if [ "$VPC_ID" == "None" ] || [ -z "$VPC_ID" ]; then
            echo "Error: Default VPC not found in region $AWS_REGION. This script assumes a default VPC exists."
            exit 1
          fi
          echo "Using Default VPC ID: $VPC_ID"

          # Check if security group already exists by name in the default VPC
          SG_ID=$(aws ec2 describe-security-groups --filters Name=group-name,Values="$SG_NAME" Name=vpc-id,Values="$VPC_ID" --query "SecurityGroups[0].GroupId" --output text --region "$AWS_REGION")

          if [ "$SG_ID" == "None" ] || [ -z "$SG_ID" ]; then
            echo "Security group '$SG_NAME' not found. Creating it..."
            SG_ID=$(aws ec2 create-security-group \
              --group-name "$SG_NAME" \
              --description "Security group for My App created by GitHub Actions" \
              --vpc-id "$VPC_ID" \
              --query 'GroupId' --output text \
              --region "$AWS_REGION")
            echo "Security Group '$SG_NAME' created with ID: $SG_ID."

            echo "Authorizing ingress rules..."
            # Allow SSH
            if ! aws ec2 authorize-security-group-ingress --group-id "$SG_ID" --protocol tcp --port 22 --cidr "$SSH_CIDR" --region "$AWS_REGION" 2>/dev/null; then
              echo "SSH rule for $SSH_CIDR might already exist or failed to add. Check AWS console."
            else
              echo "SSH access allowed from $SSH_CIDR."
            fi
            # Allow HTTP
            if ! aws ec2 authorize-security-group-ingress --group-id "$SG_ID" --protocol tcp --port 80 --cidr "0.0.0.0/0" --region "$AWS_REGION" 2>/dev/null; then
              echo "HTTP rule might already exist or failed to add."
            else
              echo "HTTP access allowed from 0.0.0.0/0."
            fi
            # Allow HTTPS
            if ! aws ec2 authorize-security-group-ingress --group-id "$SG_ID" --protocol tcp --port 443 --cidr "0.0.0.0/0" --region "$AWS_REGION" 2>/dev/null; then
              echo "HTTPS rule might already exist or failed to add."
            else
              echo "HTTPS access allowed from 0.0.0.0/0."
            fi
          else
            echo "Security group '$SG_NAME' (ID: $SG_ID) already exists. Using existing."
            # You could add logic here to verify/update rules if needed
          fi
          echo "SECURITY_GROUP_ID=$SG_ID" >> $GITHUB_OUTPUT

      - name: Launch EC2 Instance (Idempotent-ish)
        id: launch_ec2
        run: |
          INSTANCE_NAME_TAG="${{ github.event.inputs.ec2_instance_name_tag }}"
          AWS_REGION="${{ github.event.inputs.aws_region }}"
          AMI_ID="${{ github.event.inputs.ec2_ami_id }}"
          INSTANCE_TYPE="${{ github.event.inputs.ec2_instance_type }}"
          KEY_NAME="${{ github.event.inputs.ec2_key_pair_name }}"
          SG_ID="${{ steps.create_sg.outputs.SECURITY_GROUP_ID }}"

          # Check if an instance with the given name tag already exists and is not terminated
          EXISTING_INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$INSTANCE_NAME_TAG" "Name=instance-state-name,Values=pending,running,stopping,stopped" \
            --query "Reservations[*].Instances[*].InstanceId" \
            --output text --region "$AWS_REGION")

          if [ -n "$EXISTING_INSTANCE_ID" ]; then
            echo "Instance with tag Name=$INSTANCE_NAME_TAG (ID: $EXISTING_INSTANCE_ID) already exists and is not terminated. Using existing."
            INSTANCE_ID="$EXISTING_INSTANCE_ID"
            # Ensure it's running
            CURRENT_STATE=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query "Reservations[*].Instances[*].State.Name" --output text --region "$AWS_REGION")
            if [ "$CURRENT_STATE" != "running" ] && [ "$CURRENT_STATE" != "pending" ]; then
                echo "Existing instance $INSTANCE_ID is in state $CURRENT_STATE. Attempting to start it..."
                aws ec2 start-instances --instance-ids "$INSTANCE_ID" --region "$AWS_REGION"
                aws ec2 wait instance-running --instance-ids "$INSTANCE_ID" --region "$AWS_REGION"
                echo "Instance $INSTANCE_ID started."
            fi
            PUBLIC_IP=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query "Reservations[*].Instances[*].PublicIpAddress" --output text --region "$AWS_REGION")
          else
            echo "Launching new EC2 instance with Name tag: $INSTANCE_NAME_TAG..."
            # Attempt to get a default subnet ID in the first AZ of the default VPC
            DEFAULT_VPC_ID=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query "Vpcs[0].VpcId" --output text --region "$AWS_REGION")
            SUBNET_ID=$(aws ec2 describe-subnets \
              --filters Name=vpc-id,Values="$DEFAULT_VPC_ID" Name=availability-zone,Values=$(aws ec2 describe-availability-zones --query "AvailabilityZones[0].ZoneName" --output text --region "$AWS_REGION") \
              --query "Subnets[0].SubnetId" --output text --region "$AWS_REGION" 2>/dev/null)

            LAUNCH_ARGS="--image-id $AMI_ID \
                         --instance-type $INSTANCE_TYPE \
                         --key-name $KEY_NAME \
                         --security-group-ids $SG_ID \
                         --tag-specifications ResourceType=instance,Tags=[{Key=Name,Value=$INSTANCE_NAME_TAG}] ResourceType=volume,Tags=[{Key=Name,Value=${INSTANCE_NAME_TAG}-volume}] \
                         --region $AWS_REGION \
                         --query Instances[0].InstanceId --output text"

            if [ "$SUBNET_ID" != "None" ] && [ -n "$SUBNET_ID" ]; then
              echo "Using Subnet ID: $SUBNET_ID"
              LAUNCH_ARGS="$LAUNCH_ARGS --subnet-id $SUBNET_ID"
            else
              echo "Warning: Could not automatically determine a specific subnet. EC2 will pick a default subnet in the VPC."
            fi

            INSTANCE_ID=$(aws ec2 run-instances $LAUNCH_ARGS)
            echo "Instance ID: $INSTANCE_ID launched."
            echo "Waiting for instance to be in 'running' state..."
            aws ec2 wait instance-running --instance-ids "$INSTANCE_ID" --region "$AWS_REGION"
            echo "Instance is now running."
            PUBLIC_IP=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query "Reservations[*].Instances[*].PublicIpAddress" --output text --region "$AWS_REGION")
          fi

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "EC2 Instance ID: $INSTANCE_ID"
          echo "EC2 Public IP: $PUBLIC_IP"


  # ★★★★★ このジョブを修正します ★★★★★
  install_software:
    runs-on: ubuntu-latest
    needs: provision_infrastructure
    if: needs.provision_infrastructure.outputs.public_ip != ''

    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh/
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Wait for SSH to be ready
        run: |
          echo "Waiting for SSH connection to be ready..."
          sleep 30

      - name: Install Git, Docker, and Clone Repo via SSH
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          # .envファイル用の新しいSecret
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          MONGODB_DB_NAME: ${{ secrets.MONGODB_DB_NAME }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          TOKEN_ALGORITHM: ${{ secrets.TOKEN_ALGORITHM }}
          ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}
          # ワークフローからの入力
          REPO: ${{ github.event.inputs.repository_to_clone }}
          BRANCH: ${{ github.event.inputs.repository_branch }}
        run: |
          # Use the public IP from Job 1 to SSH and run installation commands
          # 'EOF' を EOF に変更。これにより、ローカル（ランナー）側で変数が展開されるようになります。
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_rsa ubuntu@${{ needs.provision_infrastructure.outputs.public_ip }} << EOF
            
            # --- Commands below are executed on the EC2 server ---
            
            echo ">>> [1/5] Installing prerequisite packages..."
            sudo apt-get update -y
            sudo apt-get install -y ca-certificates curl git

            echo ">>> [2/5] Setting up Docker's GPG key and repository..."
            sudo install -m 0755 -d /etc/apt/keyrings
            sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
            sudo chmod a+r /etc/apt/keyrings/docker.asc
            echo \
              "deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
              \$(. /etc/os-release && echo "\$VERSION_CODENAME") stable" | \
              sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

            echo ">>> [3/5] Installing Docker Engine and Compose plugin..."
            sudo apt-get update -y
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

            echo ">>> [4/5] Adding 'ubuntu' user to the docker group..."
            sudo usermod -a -G docker ubuntu

            # ★★★★★ ここからが修正箇所 ★★★★★
            echo ">>> [6/6] Cloning repository ${REPO}..."
            cd /home/ubuntu # クローン先のディレクトリに移動

            # 念のため、変数が空でないかチェックする
            if [ -z "${REPO}" ] || [ -z "${GH_PAT}" ]; then
              echo "Error: REPO or GH_PAT variable is empty on the remote server. Aborting."
              exit 1
            fi
            
            # Debug: Echo the git clone URL (do NOT do this in production as it exposes your token)
            echo "GIT CLONE URL: https://x-access-token:${GH_PAT}@github.com/${REPO}.git"
            # Use access token for authentication and clone the specified branch
            git clone -b "${BRANCH}" "https://x-access-token:${GH_PAT}@github.com/${REPO}.git"

            # ★★★★★ ここからが.envファイルを作成する修正版のステップ ★★★★★
            echo ">>> [6/6] Creating .env file..."
            
            # リポジトリのパスからディレクトリ名を取得する (例: 'core-value')
            REPO_DIR_NAME=\$(basename "\${REPO}")
            
            # クローンしたディレクトリに移動する。失敗した場合はエラーで終了する
            cd "/home/ubuntu/\${REPO_DIR_NAME}" || { echo "ERROR: Failed to cd into repo directory /home/ubuntu/\${REPO_DIR_NAME}"; exit 1; }
            
            echo "Creating .env file in \$(pwd)..."
            
            # ネストされたヒアドキュメントの代わりに、一行ずつ `echo` を使ってファイルを作成する
            # 最初の `>` はファイルを新規作成（または上書き）、次の行からの `>>` は追記を意味する
            echo "OPENAI_API_KEY=${OPENAI_API_KEY}" > .env
            echo "MONGODB_URI=${MONGODB_URI}" >> .env
            echo "MONGODB_DB_NAME=${MONGODB_DB_NAME}" >> .env
            echo "SECRET_KEY=${SECRET_KEY}" >> .env
            echo "TOKEN_ALGORITHM=${TOKEN_ALGORITHM}" >> .env
            echo "ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}" >> .env
            
            echo ".env file created successfully."
            # ★★★★★ ここまでが修正箇所 ★★★★★
            
            echo ">>> All steps complete! Server is ready."
          EOF
